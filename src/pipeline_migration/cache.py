import os
import tempfile

import logging
from pathlib import Path
from typing import Final

from pipeline_migration.utils import is_true

logger = logging.getLogger("cache")

ENV_FBC_DIR: Final = "FILE_BASED_CACHE_DIR"


class FileBasedCache:
    """A simple file-based cache mechanism

    A root directory path is required to initialize the cache. Each file
    created under this directory is called cache file. There is no restriction
    on what content can be stored in a cache file.

    Internal implementation:

    Each cache file is created as a temporary file by using the tempfile
    module. File name is in the form ``<unique key>-XXXXXX``.

    * The suffix XXXXXX is generated by the tempfile module.

    Known issue:

    As of implementing this cache, it should work well with the current
    architecture of how Mintmaker schedules Renovate CLI runs for component
    repositories.
    """

    def __init__(self, path: Path) -> None:
        self._path = path
        self._disabled = is_true(os.environ.get("FILE_BASED_CACHE_DISABLED", ""))

    def get(self, key: str) -> str | None:
        if not key:
            raise ValueError("Key is empty.")
        if self._disabled:
            logger.info("Cache is disabled. Nothing is cached.")
            return None
        cache_files = list(self._path.glob(f"{key}-*"))
        if not cache_files:
            return
        cache_file = cache_files[0]
        logger.info("Found cached content by key %s", key)
        logger.info("Return cached content from cache file %s", cache_file)
        with open(cache_files[0], "r", encoding="utf-8") as f:
            return f.read()

    def set(self, key: str, content: str) -> None:
        if not key:
            raise ValueError("Key is empty.")
        if self._disabled:
            logger.info("Cache is disabled. Nothing is set.")
            return None
        logger.info("Cache content with key key %s", key)
        fd, cache_file = tempfile.mkstemp(prefix=f"{key}-", dir=self._path)
        try:
            os.write(fd, content.encode("utf-8"))
        finally:
            os.close(fd)
        logger.info("Content is cached into file %s", cache_file)


def set_cache_dir(dir_path: str) -> None:
    cache_dir = os.environ.get(ENV_FBC_DIR)
    if cache_dir:
        if not os.path.exists(cache_dir):
            raise ValueError(f"Cache directory {cache_dir} does not exist.")
        return

    if dir_path:
        if os.path.exists(dir_path):
            os.environ[ENV_FBC_DIR] = dir_path
        else:
            raise ValueError(f"Cache directory {dir_path} does not exist.")
        return

    cache_dir = tempfile.mkdtemp(prefix="cache-dir-")
    logger.info(
        "Cache directory is not specified either from command line or by environment "
        "variable %s, use directory %s instead.",
        ENV_FBC_DIR,
        cache_dir,
    )
    os.environ[ENV_FBC_DIR] = cache_dir


def get_cache() -> FileBasedCache:
    cache_dir = os.environ.get(ENV_FBC_DIR)
    if not cache_dir:
        raise ValueError(f"Missing environment variable {ENV_FBC_DIR}.")
    dir_path = Path(cache_dir)
    if not dir_path.exists():
        raise ValueError(f"Cache directory {dir_path} does not exist.")
    return FileBasedCache(dir_path)
