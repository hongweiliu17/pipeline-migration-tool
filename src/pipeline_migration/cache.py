import os
import tempfile

from pathlib import Path


class FileBasedCache:
    """A simple file-based cache mechanism

    A root directory path is required to initialize the cache. Each file created under this
    directory is called cache file. There is no restriction on what content can be stored in a
    cache file. Instead, it depends on the cache consumer to provide the cache key and content.

    Internal implementation:

    Each cache file is created as a temporary file by using the tempfile module. File name is in
    the form ``<content type>-<unique key>-XXXXXX``.

    * <content type> could be ``image-manifest`` or ``migration``.
    * <unique key> is unique to the content type. For instance, for an image manifest, it can be
      ``depName-<digest: sha256:123456>``, and for a migration file, it can be
      ``depName-<task version: 0.1.1>``.
    * The suffix XXXXXX is generated by the tempfile module.

    Known issue:

    As of implementing this cache, it should just work well for the current
    architecture of how Mintmaker schedules Renovate CLI runs for component repositories.

    TODO: describe the arch a little bit.
    """

    def __init__(self, path: Path) -> None:
        self._path = path

    @staticmethod
    def _cache_file_key(content_type: str, key: str) -> str:
        return f"{content_type}-{key}"

    def read(self, content_type: str, key: str) -> str | None:
        cache_key = self._cache_file_key(content_type, key)
        cache_files = self._path.glob(f"{cache_key}-*")
        if not cache_files:
            return
        with open(cache_files[0], "r", encoding="utf-8") as f:
            return f.read()

    def write(self, content_type: str, key: str, content: str) -> None:
        cache_key = self._cache_file_key(content_type, key)
        fd, cache_file = tempfile.mkstemp(prefix=f"{cache_key}-", dir=self._path)
        try:
            os.write(fd, content.encode("utf-8"))
        finally:
            os.close(fd)
