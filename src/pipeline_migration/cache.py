import os
import tempfile

import logging
from pathlib import Path
from typing import Final, TypedDict

logger = logging.getLogger("cache")

ENV_CACHE_DIR: Final = "FILE_BASED_CACHE_DIR"
CACHE_DIR_PREFIX: Final = "pmt-cache-dir-"


class CacheConfigT(TypedDict):
    cache_dir: str
    disabled: bool


class FileBasedCache:
    """A simple file-based cache mechanism

    A root directory path is required to initialize the cache. Each file
    created under this directory is called cache file. There is no restriction
    on what content can be stored in a cache file.

    Internal implementation:

    Each cache file is created as a temporary file by using the tempfile
    module. File name is in the form ``<unique key>-XXXXXX``.

    * The suffix XXXXXX is generated by the tempfile module.

    Known issue:

    As of implementing this cache, it should work well with the current
    architecture of how Mintmaker schedules Renovate CLI runs for component
    repositories.
    """

    config: CacheConfigT = {
        "cache_dir": "",
        "disabled": False,
    }

    @classmethod
    def configure(cls, cache_dir: str, disable: bool = False):
        cls.config["cache_dir"] = cache_dir
        cls.config["disabled"] = disable

    @classmethod
    def validate_config(cls) -> None:
        if not cls.config["cache_dir"]:
            raise ValueError("Cache directory path is not set yet.")
        cache_dir = Path(cls.config["cache_dir"])
        if not cache_dir.is_absolute():
            raise ValueError(f"Cache directory {str(cache_dir)} is not an absolute path.")
        if not cache_dir.is_dir():
            raise IOError(f"Path {str(cache_dir)} is not a directory.")
        return None

    def __new__(cls, *args, **kwargs):
        cls.validate_config()
        return super().__new__(cls, *args, **kwargs)

    @property
    def path(self) -> Path:
        return Path(self.config["cache_dir"])

    @property
    def disabled(self) -> bool:
        return self.config["disabled"]

    def get(self, key: str) -> str | None:
        if not key:
            raise ValueError("Key is empty.")
        if self.disabled:
            logger.info("Cache is disabled. Nothing is cached.")
            return None
        cache_files = list(self.path.glob(f"{key}-*"))
        if not cache_files:
            return None
        cache_file = cache_files[0]
        logger.info("Found cached content by key %s", key)
        logger.info("Return cached content from cache file %s", cache_file)
        with open(cache_files[0], "r", encoding="utf-8") as f:
            return f.read()

    def set(self, key: str, content: str) -> None:
        if not key:
            raise ValueError("Key is empty.")
        if self.disabled:
            logger.info("Cache is disabled. Nothing is set.")
            return None
        logger.info("Cache content with key key %s", key)
        fd, cache_file = tempfile.mkstemp(prefix=f"{key}-", dir=self.path)
        try:
            os.write(fd, content.encode("utf-8"))
        finally:
            os.close(fd)
        logger.info("Content is cached into file %s", cache_file)
